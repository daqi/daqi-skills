<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Markdownè½¬å°çº¢ä¹¦é•¿æ–‡å›¾å·¥å…·</title>
    <script src="https://registry.npmmirror.com/marked/17.0.1/files/lib/marked.umd.js"></script>
    <script src="https://registry.npmmirror.com/dom-to-image-more/3.7.2/files/dist/dom-to-image-more.min.js"></script>
    <script src="https://registry.npmmirror.com/jszip/3.10.1/files/dist/jszip.min.js"></script>
    
    <style>
        :root {
            --p-width: 450px;
            --p-height: 600px;
            --p-padding: 40px;
            --p-font-size: 16px;
            --p-title-size: 2.4em;
            --p-gap: calc(var(--p-padding) * 2);
            --sidebar-width: 400px;
        }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: -apple-system, sans-serif; background: #f0f2f5; }

        .app-container { display: flex; height: 100vh; width: 100vw; }

        /* --- å·¦ä¾§ç¼–è¾‘åŒº --- */
        .left-panel {
            width: var(--sidebar-width);
            background: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #d0d7de;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .config-header { padding: 20px; border-bottom: 1px solid #eee; }
        .config-header h2 { margin: 0 0 15px 0; font-size: 18px; color: #1a1a1a; }

        .config-group { display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px; }
        .config-item { display: flex; flex-direction: column; gap: 5px; }
        .config-item label { font-size: 12px; font-weight: bold; color: #666; display: flex; justify-content: space-between; }

        #md-input {
            flex: 1;
            border: none;
            padding: 20px;
            font-family: "Fira Code", monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            background: #fafafa;
        }

        .action-btns { padding: 20px; background: white; border-top: 1px solid #eee; display: flex; flex-direction: column; gap: 10px; }

        /* --- å³ä¾§é¢„è§ˆåŒº --- */
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            background: #e5e7eb;
            padding: 40px;
        }

        .nav-bar {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(255,255,255,0.8);
            padding: 8px 16px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
        }
        .pagination-dots {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }
        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #c9d1d9;
            cursor: pointer;
        }
        .dot.active { background: #24292f; }
        .dot:hover { background: #6e7781; }

        #viewport {
            width: var(--p-width);
            height: var(--p-height);
            min-width: var(--p-width);
            min-height: var(--p-height);
            background: white;
            overflow: hidden;
            position: relative;
            box-shadow: 0 30px 60px rgba(0,0,0,0.12);
            border-radius: 4px;
        }

        #content-wrapper {
            width: var(--p-width);
            height: var(--p-height);
            column-width: var(--p-width);
            column-gap: var(--p-gap);
            column-fill: auto;
            box-sizing: border-box;
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* --- GitHub æ ·å¼ Markdown --- */
        .md-body { padding: var(--p-padding); font-size: var(--p-font-size); line-height: 1.9; word-wrap: break-word; color: #24292f; font-family: "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", -apple-system, sans-serif; font-kerning: none; font-variant-ligatures: none; font-feature-settings: "kern" 0, "liga" 0, "clig" 0; text-rendering: geometricPrecision; letter-spacing: 0; }
        .md-body h1 { padding-bottom: 0.3em; line-height: 1.3; font-size: var(--p-title-size); margin: 0.4em 0 0.3em; }
        .md-body h2 { margin: 0.45em 0 0.25em; font-size: 1.35em; }
        .md-body h3 { margin: 0.4em 0 0.2em; font-size: 1.2em; }
        .md-body blockquote { border-left: 4px solid #d0d7de; padding-left: 16px; color: #57606a; margin: 0 0 16px 0; }
        .md-body img { max-width: 100%; border-radius: 6px; }
        .md-body .hero-wrapper { margin: 0; }
        .md-body img.hero-image {
            display: block;
            width: calc(100% + (var(--p-padding) * 2));
            margin: calc(-1 * var(--p-padding)) calc(-1 * var(--p-padding)) var(--p-padding);
            max-width: none;
            border-radius: 0;
        }
        .md-body pre { background: #f6f8fa; padding: 16px; border-radius: 6px; overflow: hidden; }
        .md-body h1, .md-body img, .md-body pre, .md-body blockquote { break-inside: avoid; }

        /* æŒ‰é’®æ ·å¼ */
        button { border: none; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: 0.2s; }
        .btn-zip { background: #2da44e; color: white; width: 100%; }
        .btn-zip:hover { background: #2c974b; }
        .btn-nav { background: white; border: 1px solid #d0d7de; }
        .btn-nav:hover { background: #f6f8fa; border-color: #b6bec8; }
        .btn-nav.active { background: #24292f; color: white; border-color: #24292f; }
        .btn-nav:disabled { opacity: 0.4; }
    </style>
</head>
<body>

<div class="app-container">
    <div class="left-panel">
        <div class="config-header">
            <h2>é…ç½®ä¸ç¼–è¾‘</h2>
            <div class="config-group">
                <div class="config-item">
                    <label>å­—ä½“å¤§å° <span id="v-fs">16px</span></label>
                    <input type="range" id="in-fs" min="12" max="24" value="16">
                </div>
                <div class="config-item">
                    <label>æ ‡é¢˜å¤§å° <span id="v-title">1.8em</span></label>
                    <input type="range" id="in-title" min="1.8" max="3" value="2.4" step="0.1">
                </div>
                <div class="config-item">
                    <label>è¾¹è·å¤§å° <span id="v-pd">40px</span></label>
                    <input type="range" id="in-pd" min="10" max="80" value="40">
                </div>
                <div class="config-item">
                    <label>å¡ç‰‡æ¯”ä¾‹ <span id="v-ratio">3:4</span></label>
                    <div style="display:flex;gap:8px;">
                        <button class="btn-nav" type="button" id="ratio-34">3:4</button>
                        <button class="btn-nav" type="button" id="ratio-35">3:5</button>
                    </div>
                </div>
            </div>
            <h2 style="margin-bottom: 0">Markdown æ–‡æ¡£</h2>
        </div>
        <textarea id="md-input" placeholder="æ”¯æŒ Markdown å®æ—¶é¢„è§ˆ..."></textarea>

        <div class="action-btns">
            <div style="font-size:12px;color:#666;margin-bottom:8px;">æç¤º: æ”¯æŒç²˜è´´æˆ–æ‹–æ‹½å›¾ç‰‡ï¼Œè‡ªåŠ¨æ’å…¥ä¸º Blob URLï¼ˆåˆ·æ–°åå¤±æ•ˆï¼‰ã€‚</div>
            <div id="status" style="font-size:12px;color:#666;margin-bottom:8px;"></div>
            <button class="btn-zip" id="zip-btn" onclick="captureAndZip()">æ‰“åŒ…ä¸‹è½½å…¨éƒ¨å¡ç‰‡ (ZIP)</button>
        </div>
    </div>

    <div class="right-panel">
        <div class="nav-bar">
            <button class="btn-nav" onclick="goFirst()">&lt;&lt;</button>
            <button class="btn-nav" onclick="changePage(-1)">&lt;</button>
            <span id="page-info" style="font-weight: bold; font-variant-numeric: tabular-nums;">1 / 1</span>
            <button class="btn-nav" onclick="changePage(1)">&gt;</button>
            <button class="btn-nav" onclick="goLast()">&gt;&gt;</button>
        </div>

        <div id="viewport">
            <div id="content-wrapper" class="md-body"></div>
        </div>
        <div id="page-dots" class="pagination-dots"></div>
    </div>
</div>
<div style="display: none;" id="demo">
# å†™ä½œä¸æ˜¯ä»é›¶å¼€å§‹ï¼Œæ˜¯ä¸€æ¡ä¼šè¶Šæ¥è¶Šå¿«çš„æµæ°´çº¿ã€‚  

ğŸ“³ æ˜¨æ™šæ‰‹æœºéœ‡åŠ¨åˆ°åœä¸ä¸‹æ¥ã€‚  

æˆ‘æ˜¨å¤©å‘äº†ä¸€ç¯‡ï¼šã€ŠMarkdown ä¸€é”®å˜å°çº¢ä¹¦å›¾ç‰‡ã€‹ã€‚  

æœ¬æ¥åªæƒ³ç»“æŸï¼šä¸ºäº†å‘ä¸€ç¯‡ç¬”è®°ã€‚  

æ²¡æƒ³åˆ°è¯„è®ºåŒºç›´æ¥ç‚¸äº†ï¼š  

â€œç»ˆäºæœ‰äººåšè¿™ä¸ªäº†ã€‚â€  
â€œæˆ‘æ»´å¦ˆè¿™ä¸ªä¹Ÿå¤ªæœ‰ç”¨äº†ï¼â€  
â€œæˆ‘ä¹Ÿç¢°åˆ°è¿™ä¸ªé—®é¢˜ï¼â€  
â€œæˆ‘ç”¨ Typora å¯¼ PDF + å¿«æ·æŒ‡ä»¤è½¬å›¾ï¼Œä½†æ ·å¼æ°¸è¿œè°ƒä¸é¡ºã€‚â€  
â€œå‘ä¸ªæ–‡è¿˜å¾—æ‰‹å·¥æˆªå›¾ Notionï¼Œå‘ä¸€æ¬¡å°±ä¸æƒ³å‘äº†ã€‚â€  

æ›´ç¦»è°±çš„æ˜¯ï¼š  

æˆ‘ä¸Šä¸€ç¯‡ç»“å°¾è®©å¤§å®¶è¯„è®º **â€œå†…æµ‹â€**ã€‚  

ä¸€æ™šä¸Šå°±æœ‰ 16 ä¸ªäººæ¥æ”¯æŒã€‚  

æˆ‘å’Œå‡ ä¸ªåˆ›ä½œè€…èŠå®Œï¼Œæ‰å‘ç°ï¼š  

**ç¼ºçš„ä¸æ˜¯å·¥å…·ã€‚**  

**ç¼ºçš„æ˜¯ä¸€æ¡å®Œæ•´çš„åˆ›ä½œæµæ°´çº¿ã€‚**  

ç®€å•è¯´ï¼šè®©åˆ›ä½œåƒåšé¥­ä¸€æ ·ã€‚  

èœåœ¨å†°ç®±é‡Œï¼ˆç´ æï¼‰ï¼Œçµæ„Ÿåƒçªç„¶æƒ³åƒè¾£ï¼ˆæƒ³æ³•ï¼‰ï¼Œå†™ç¨¿æ˜¯ä¸‹é”…ï¼ˆæˆæ–‡ï¼‰ï¼Œå‘å¸ƒæ˜¯è£…ç›˜ä¸Šæ¡Œã€‚  

ç°åœ¨çš„é—®é¢˜æ˜¯â€”â€”ä½ å¾—åœ¨äº”ä¸ªå¨æˆ¿æ¥å›è·‘ã€‚  

ä½ çœ‹å¤§å¤šæ•°äººçš„åˆ›ä½œï¼š  

ç´ æåœ¨æ”¶è—å¤¹ï¼Œçµæ„Ÿåœ¨å¤‡å¿˜å½•ï¼Œæ–‡æ¡ˆåœ¨ Typora / Notionï¼Œå›¾ç‰‡é æˆªå›¾ï¼Œå‘å¸ƒå»å°çº¢ä¹¦åå°ã€‚  

å…¨æ˜¯å­¤å²›ã€‚  

æ²¡æœ‰ä¸Šä¸‹æ–‡ã€‚  
æ²¡æœ‰è®°å¿†ã€‚  
æ²¡æœ‰åä½œã€‚  

æ‰€ä»¥æ¯æ¬¡éƒ½å¾—ä»é›¶å¼€å§‹ã€‚  


çœŸæ­£é«˜æ•ˆçš„åˆ›ä½œåº”è¯¥æ˜¯ï¼š  

ç´ æ â†’ çµæ„Ÿ â†’ æ–‡æ¡ˆ â†’ å‘å¸ƒ  

ä¸€æ¡è¿ç»­çš„â€œä¼ é€å¸¦â€ã€‚  

ç´ æè¢« AI ç†è§£  
çµæ„Ÿè¢« AI æç‚¼  
æ–‡æ¡ˆåŸºäºç´ æç”Ÿæˆ  
å‘å¸ƒè‡ªåŠ¨æ ¼å¼åŒ–  

ä½ ä¼šæ˜æ˜¾æ„Ÿè§‰ï¼š  

ä¸æ˜¯æ¯æ¬¡æ†‹ä¸€ç¯‡ã€‚  

è€Œæ˜¯è¶Šå†™è¶ŠçœåŠ›ã€‚  


è¯´å®è¯ï¼Œè¿™å¥—æµç¨‹æˆ‘å·²ç»åœ¨ç”¨ã€‚  

æˆ‘ç”¨ VSCode + Markdown + AIï¼Œæ­äº†ä¸€ä¸ªå®Œæ•´çš„æœ¬åœ°åˆ›ä½œç³»ç»Ÿã€‚  

ç´ æã€çµæ„Ÿã€æ–‡æ¡ˆã€å‘å¸ƒã€‚  

å…¨éƒ¨åœ¨ä¸€ä¸ªç¯å¢ƒé‡Œå®Œæˆã€‚  

æ•ˆç‡çœŸçš„å¾ˆå¤¸å¼ ã€‚  

ä½†æˆ‘å¾ˆå¿«è¢«ç°å®æ‰“äº†ä¸€ä¸‹ï¼š  

**è¿™å¥—æ–¹å¼ï¼Œåªå±äºç¨‹åºå‘˜ã€‚**  

VSCode å¤ªå¤æ‚ã€‚  
æ–‡ä»¶ç³»ç»Ÿå¤ªæŠ½è±¡ã€‚  
AI é‚£å¥—é…ç½®æµç¨‹æ›´æ˜¯åŠé€€ã€‚  

æˆ‘å½“æ—¶å…¶å®æœ‰ç‚¹æ…Œã€‚  

å› ä¸ºæˆ‘å¾ˆæ¸…æ¥šï¼š  

æˆ‘èƒ½ç”¨ï¼Œä¸ç­‰äºä½ èƒ½ç”¨ã€‚  


æ‰€ä»¥æˆ‘å†³å®šæŠŠè¿™å¥—æµç¨‹åšæˆä¸€ä¸ªçœŸæ­£çš„åº”ç”¨ã€‚  

ä¸€ä¸ªä¸“é—¨ä¸ºå°çº¢ä¹¦åˆ›ä½œè€…è®¾è®¡çš„ï¼š  

**AI åˆ›ä½œå·¥ä½œç«™ï¼ˆæœ¬åœ°ä¼˜å…ˆï¼‰**  

å®ƒä¸æ˜¯é‚£ç§â€œæŠŠå†…å®¹ä¸¢è¿›äº‘ç«¯â€çš„ç¬”è®°äº§å“ã€‚  

å®ƒæ›´åƒä¸€ä¸ªè£…åœ¨ä½ ç”µè„‘é‡Œçš„åˆ›ä½œå·¥ä½œå°ã€‚  

æ‰€æœ‰å†…å®¹éƒ½åœ¨ä½ ç”µè„‘é‡Œï¼šä¸€ç¯‡ç¯‡ç¨¿å­ï¼ˆæ–‡æœ¬æ–‡ä»¶ï¼‰ã€‚  

AI ä¹Ÿä¸ä¼šæ˜¯é»‘ç›’ä¹±çŒœã€‚  

å®ƒåªåœ¨ä½ çš„ç´ æåº“é‡Œæ‰¾ä¸œè¥¿ã€å¸®ä½ ç»„ç»‡ã€å¸®ä½ å†™ã€‚  

å®ƒâ€œçŸ¥é“â€ï¼š  

ä½ æ”¶è—è¿‡ä»€ä¹ˆ  
ä½ å†™è¿‡ä»€ä¹ˆ  
ä½ å…³æ³¨ä»€ä¹ˆ  
ä½ æ­£åœ¨åˆ›ä½œä»€ä¹ˆ  


åœ¨è¿™ä¸ªåº”ç”¨é‡Œï¼Œåˆ›ä½œä¼šå˜æˆè¿™æ ·ï¼š  

ä½ ä¿å­˜ä¸€ç¯‡çˆ†æ–‡ â†’ è‡ªåŠ¨è¿›ç´ æåº“  

ä½ å†™ä¸‹ä¸€å¥æƒ³æ³• â†’ è‡ªåŠ¨å…³è”ç›¸å…³ç´ æ  

ä½ è¾“å…¥ä¸€ä¸ªæ ‡é¢˜ â†’ AI åŸºäºä½ çš„ç´ æç”Ÿæˆåˆç¨¿  

ä½ ç‚¹å‡»å‘å¸ƒ â†’ è‡ªåŠ¨ç”Ÿæˆå°çº¢ä¹¦é•¿æ–‡å›¾ç‰‡æ ¼å¼  

æ•´ä¸ªè¿‡ç¨‹æ˜¯è¿ç»­çš„ã€‚  

ä¸æ˜¯å‰²è£‚çš„ã€‚  


æ›´é‡è¦çš„æ˜¯ï¼š  

**è¿™æ˜¯â€œå†…å®¹å…ˆæ”¾åœ¨ä½ ç”µè„‘é‡Œâ€çš„ã€‚**  

ä½ çš„å†…å®¹æ°¸è¿œåœ¨æœ¬åœ°ã€‚  

ä¸ä¾èµ–å¹³å°ã€‚  
ä¸é”æ­»ç”Ÿæ€ã€‚  
ä¸æ€•äº§å“æ¶ˆå¤±ã€‚  

æœªæ¥å¯ä»¥åŒæ­¥ã€‚  

ä½†â€œæœ¬åœ°â€ï¼Œæ°¸è¿œæ˜¯æ ¹ã€‚  


ä½ å¯ä»¥æŠŠå®ƒç†è§£æˆï¼š  

Typora + ç´ æåº“ + AI + å°çº¢ä¹¦å‘å¸ƒ  

ä½†æˆ‘æƒ³åšçš„æ˜¯ï¼š  

ä½ ä¸ç”¨åœ¨å››ä¸ªåœ°æ–¹æ¥å›åˆ‡ã€‚  

æ‰€æœ‰ä¸œè¥¿åœ¨ä¸€ä¸ªåœ°æ–¹ï¼Œå‰åèƒ½ä¸²èµ·æ¥ã€‚  


æˆ‘åšäº†ä¸ªzuiç›´è§‚çš„å¯¹æ¯”ï¼š  

ä»¥å‰ï¼š  

æ”¶è— â†’ å¿˜è®°  
å†™ä½œ â†’ ä»é›¶å¼€å§‹  
å‘å¸ƒ â†’ æ‰‹åŠ¨å¤„ç†æ ¼å¼  

ç°åœ¨ï¼š  

ç´ æ â†’ å¯è¢« AI ç›´æ¥è°ƒç”¨  
å†™ä½œ â†’ åŸºäºç´ æç”Ÿæˆ  
å‘å¸ƒ â†’ ä¸€é”®å®Œæˆ  

**åˆ›ä½œç¬¬ä¸€æ¬¡å˜æˆâ€œå¯ç§¯ç´¯çš„èµ„äº§â€ã€‚**  


è¿™ä¸ªé¡¹ç›®åˆšå¼€å§‹ã€‚  

ç¬¬ä¸€é˜¶æ®µä¼˜å…ˆæ”¯æŒï¼š  

Markdown å†™ä½œ  
ç´ æåº“  
AI å†™ä½œ  
ä¸€é”®ç”Ÿæˆå°çº¢ä¹¦é•¿æ–‡å›¾ç‰‡  

åé¢é€æ­¥åŠ ï¼š  

çµæ„Ÿç³»ç»Ÿ  
é€‰é¢˜å¼•æ“  
è‡ªåŠ¨å‘å¸ƒ  
æœ¬åœ° AI æ”¯æŒ  


å¦‚æœä½ ä¹Ÿæ˜¯å°çº¢ä¹¦åˆ›ä½œè€…ï¼Œ  

æˆ–è€…ä½ ä¹Ÿä¹ æƒ¯ç”¨ Markdown å†™ä½œï¼Œ  

æƒ³ä¸€èµ·æŠŠå®ƒæ‰“ç£¨å‡ºæ¥ï¼Œè¯„è®ºåŒºæ‰“ä¸€å¥ï¼š  

**â€œæƒ³å‚ä¸â€**  

æˆ‘ä¼šä¼˜å…ˆé‚€è¯·æ„¿æ„è®¤çœŸç»™åé¦ˆçš„äººä¸€èµ·å‚ä¸è®¾è®¡ã€‚  

ï¼ˆæ¯”å¦‚ï¼šä½ ç°åœ¨ç”¨ä»€ä¹ˆå†™ä½œ/æ’ç‰ˆå·¥å…·ï¼Ÿæœ€ç—›çš„ä¸€æ­¥æ˜¯å“ªä¸€æ­¥ï¼Ÿï¼‰  

è¿™ä¸åªæ˜¯åšä¸€ä¸ªå°å·¥å…·ã€‚  

æˆ‘æ›´æƒ³å’Œä½ ä¸€èµ·ï¼ŒæŠŠåˆ›ä½œè¿™ä»¶äº‹é‡æ–°è®¾è®¡ä¸€éã€‚  
</div>

<script>
    const wrapper = document.getElementById('content-wrapper');
    const viewport = document.getElementById('viewport');
    const input = document.getElementById('md-input');

    input.value = document.getElementById('demo').innerText.trim();
    
    const createdBlobs = [];
    
    let currentPage = 0;
    let totalPages = 0;

    // å®æ—¶ç›‘å¬è¾“å…¥
    input.addEventListener('input', render);

    // æ”¯æŒç²˜è´´å›¾ç‰‡ä¸º blob URL å¹¶æ’å…¥åˆ° Markdown
    input.addEventListener('paste', async function(e) {
        const items = (e.clipboardData || window.clipboardData).items;
        if (!items) return;
        await handleImageItems(items, e);
    });
    function insertAtCursor(el, text) {
        const start = el.selectionStart || 0;
        const end = el.selectionEnd || 0;
        const v = el.value;
        el.value = v.slice(0,start) + text + v.slice(end);
        const pos = start + text.length;
        el.selectionStart = el.selectionEnd = pos;
        el.focus();
    }

    function setCursorFromPoint(el, x, y) {
        const pos = getCaretIndexFromPoint(el, x, y);
        if (typeof pos === 'number') {
            el.selectionStart = el.selectionEnd = pos;
        }
        el.focus();
    }

    const measureCanvas = document.createElement('canvas');
    const measureCtx = measureCanvas.getContext('2d');
    function measureWidth(text) {
        return measureCtx.measureText(text).width;
    }
    function wrapLine(text, maxWidth) {
        if (text.length === 0) return [{ start: 0, end: 0 }];
        const segments = [];
        let start = 0;
        while (start < text.length) {
            let low = start;
            let high = text.length;
            let fit = start;
            while (low <= high) {
                const mid = Math.floor((low + high) / 2);
                const w = measureWidth(text.slice(start, mid));
                if (w <= maxWidth) {
                    fit = mid;
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            if (fit === start) fit = Math.min(start + 1, text.length);
            segments.push({ start, end: fit });
            start = fit;
        }
        return segments;
    }
    function findCharIndexInSegment(text, maxWidth, x) {
        if (x <= 0) return 0;
        let low = 0;
        let high = text.length;
        let fit = 0;
        while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            const w = measureWidth(text.slice(0, mid));
            if (w <= maxWidth && w <= x) {
                fit = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return fit;
    }
    function getCaretIndexFromPoint(el, x, y) {
        const rect = el.getBoundingClientRect();
        const style = getComputedStyle(el);
        const paddingLeft = parseFloat(style.paddingLeft) || 0;
        const paddingTop = parseFloat(style.paddingTop) || 0;
        const paddingRight = parseFloat(style.paddingRight) || 0;
        const fontSize = parseFloat(style.fontSize) || 14;
        const lineHeight = parseFloat(style.lineHeight) || Math.round(fontSize * 1.2);
        const font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
        measureCtx.font = font;

        const relX = x - rect.left - paddingLeft + el.scrollLeft;
        const relY = y - rect.top - paddingTop + el.scrollTop;
        const lines = (el.value || '').split('\n');
        if (lines.length === 0) return 0;

        const contentWidth = rect.width - paddingLeft - paddingRight;
        const visualLineIndex = Math.max(0, Math.floor(relY / lineHeight));

        let visualCount = 0;
        let lineIndex = 0;
        let segment = { start: 0, end: 0 };
        for (let i = 0; i < lines.length; i++) {
            const segs = wrapLine(lines[i], contentWidth);
            if (visualLineIndex < visualCount + segs.length) {
                lineIndex = i;
                segment = segs[visualLineIndex - visualCount];
                break;
            }
            visualCount += segs.length;
            lineIndex = i;
            segment = segs[segs.length - 1];
        }

        const segText = lines[lineIndex].slice(segment.start, segment.end);
        const colInSeg = findCharIndexInSegment(segText, contentWidth, Math.max(0, relX));
        const col = Math.min(lines[lineIndex].length, segment.start + colInSeg);

        let index = 0;
        for (let i = 0; i < lineIndex; i++) {
            index += lines[i].length + 1;
        }
        return index + col;
    }

    async function handleImageItems(items, e) {
        let handled = false;
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.type && item.type.indexOf('image') !== -1) {
                const file = item.getAsFile();
                if (!file) continue;
                const url = URL.createObjectURL(file);
                createdBlobs.push(url);
                const alt = file.name || 'pasted-image';
                insertAtCursor(input, `![${alt}](${url})\n\n`);
                handled = true;
            }
        }
        if (handled) {
            if (e) e.preventDefault();
            render();
        }
    }

    async function handleImageFiles(files, e) {
        let handled = false;
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            if (!file || !file.type || file.type.indexOf('image') !== 0) continue;
            const url = URL.createObjectURL(file);
            createdBlobs.push(url);
            const alt = file.name || 'dropped-image';
            insertAtCursor(input, `![${alt}](${url})\n\n`);
            handled = true;
        }
        if (handled) {
            if (e) e.preventDefault();
            render();
        }
    }

    // åœ¨é¡µé¢å¸è½½å‰æ’¤é”€åˆ›å»ºçš„ blob URLï¼Œé‡Šæ”¾å†…å­˜
    window.addEventListener('beforeunload', function() {
        createdBlobs.forEach(u => {
            try { URL.revokeObjectURL(u); } catch(e) {}
        });
    });

    // æ‹–æ‹½å›¾ç‰‡åˆ°ç¼–è¾‘åŒº
    input.addEventListener('dragover', function(e) {
        e.preventDefault();
    });
    input.addEventListener('drop', async function(e) {
        setCursorFromPoint(input, e.clientX, e.clientY);
        const files = e.dataTransfer && e.dataTransfer.files;
        if (files && files.length) {
            await handleImageFiles(files, e);
            return;
        }
        const items = e.dataTransfer && e.dataTransfer.items;
        if (!items) return;
        await handleImageItems(items, e);
    });

    // é…ç½®é¡¹å®æ—¶ç”Ÿæ•ˆ
    const controls = { 'in-fs': '--p-font-size', 'in-pd': '--p-padding' };
    Object.keys(controls).forEach(id => {
        document.getElementById(id).oninput = function() {
            const val = this.value + 'px';
            document.documentElement.style.setProperty(controls[id], val);
            document.getElementById('v-' + id.split('-')[1]).innerText = val;
            updateLayout();
        };
    });

    document.getElementById('in-title').oninput = function() {
        const val = this.value + 'em';
        document.documentElement.style.setProperty('--p-title-size', val);
        document.getElementById('v-title').innerText = val;
        updateLayout();
    };

    function setRatio(width, height) {
        document.documentElement.style.setProperty('--p-width', width + 'px');
        document.documentElement.style.setProperty('--p-height', height + 'px');
        document.getElementById('v-ratio').innerText = `${width / 150}:${height / 150}`;
        document.getElementById('ratio-34').classList.toggle('active', height === 600);
        document.getElementById('ratio-35').classList.toggle('active', height === 750);
        updateLayout();
    }
    document.getElementById('ratio-34').addEventListener('click', function() {
        setRatio(450, 600);
    });
    document.getElementById('ratio-35').addEventListener('click', function() {
        setRatio(450, 750);
    });
    setRatio(450, 600);

    function getStep() {
        const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--p-gap')) || 0;
        return viewport.offsetWidth + gap;
    }

    function render() {
        const content = input.value || "# æ¬¢è¿ä½¿ç”¨\nåœ¨å·¦ä¾§è¾“å…¥ Markdownï¼Œå³ä¾§å®æ—¶é¢„è§ˆåˆ†é¡µã€‚\n\n## ä¼˜ç‚¹\n- **å·¦å³ç»“æ„**ï¼šç¼–è¾‘æ›´é«˜æ•ˆ\n- **è‡ªåŠ¨åˆ†é¡µ**ï¼šä¸æŒ‰æ®µè½ï¼ŒæŒ‰è¡Œåˆ‡åˆ†\n- **3:4 æ¯”ä¾‹**ï¼šé€‚åˆå°çº¢ä¹¦/æµ·æŠ¥";
        wrapper.innerHTML = marked.parse(content);
        applyHeroImage();
        waitForImages();
    }

    function applyHeroImage() {
        wrapper.querySelectorAll('img.hero-image').forEach(img => img.classList.remove('hero-image'));
        wrapper.querySelectorAll('.hero-wrapper').forEach(el => el.classList.remove('hero-wrapper'));

        let firstMeaningful = null;
        for (const node of wrapper.childNodes) {
            if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() === '') continue;
            if (node.nodeType === Node.COMMENT_NODE) continue;
            firstMeaningful = node;
            break;
        }
        if (!firstMeaningful || firstMeaningful.nodeType !== Node.ELEMENT_NODE) return;

        if (firstMeaningful.tagName === 'IMG') {
            firstMeaningful.classList.add('hero-image');
            return;
        }

        if (firstMeaningful.tagName === 'P') {
            const text = firstMeaningful.textContent.trim();
            const imgs = firstMeaningful.querySelectorAll('img');
            if (text === '' && imgs.length === 1) {
                firstMeaningful.classList.add('hero-wrapper');
                imgs[0].classList.add('hero-image');
            }
        }
    }

    function waitForImages() {
        const imgs = wrapper.querySelectorAll('img');
        let pending = 0;
        imgs.forEach(img => {
            if (!img.complete) {
                pending++;
                img.addEventListener('load', () => {
                    pending--;
                    if (pending === 0) updateLayout();
                }, { once: true });
                img.addEventListener('error', () => {
                    pending--;
                    if (pending === 0) updateLayout();
                }, { once: true });
            }
        });
        if (pending === 0) updateLayout();
    }

    function updateLayout() {
        const step = getStep();
        totalPages = Math.ceil((wrapper.scrollWidth + (step - viewport.offsetWidth)) / step) || 1;
        if (currentPage >= totalPages) currentPage = totalPages - 1;
        applyTransform();
        document.getElementById('page-info').innerText = `${currentPage + 1} / ${totalPages}`;
        renderDots();
    }

    function changePage(dir) {
        currentPage = Math.max(0, Math.min(totalPages - 1, currentPage + dir));
        applyTransform();
        document.getElementById('page-info').innerText = `${currentPage + 1} / ${totalPages}`;
        renderDots();
    }

    function goFirst() {
        currentPage = 0;
        applyTransform();
        document.getElementById('page-info').innerText = `${currentPage + 1} / ${totalPages}`;
        renderDots();
    }

    function goLast() {
        currentPage = Math.max(0, totalPages - 1);
        applyTransform();
        document.getElementById('page-info').innerText = `${currentPage + 1} / ${totalPages}`;
        renderDots();
    }

    function renderDots() {
        const dots = document.getElementById('page-dots');
        if (!dots) return;
        dots.innerHTML = '';
        for (let i = 0; i < totalPages; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot' + (i === currentPage ? ' active' : '');
            dot.addEventListener('click', () => {
                currentPage = i;
                applyTransform();
                document.getElementById('page-info').innerText = `${currentPage + 1} / ${totalPages}`;
                renderDots();
            });
            dots.appendChild(dot);
        }
    }

    function applyTransform() {
        wrapper.style.transform = `translateX(-${currentPage * getStep()}px)`;
    }

    async function captureAndZip() {
        const zip = new JSZip();
        const originalPage = currentPage;
        const btn = document.getElementById('zip-btn');
        const statusEl = document.getElementById('status');
        btn.disabled = true;

        if (document.fonts && document.fonts.ready) {
            await document.fonts.ready;
        }

        for (let i = 0; i < totalPages; i++) {
            if (statusEl) statusEl.innerText = `å¯¼å‡ºä¸­: ${i+1}/${totalPages}`;
            currentPage = i;
            applyTransform();
            await new Promise(r => setTimeout(r, 400));

            const dataUrl = await domtoimage.toPng(viewport, {
                cacheBust: true,
                scale: 3,
                style: {
                    fontKerning: 'none',
                    fontVariantLigatures: 'none',
                    fontFeatureSettings: '"kern" 0, "liga" 0, "clig" 0',
                    letterSpacing: '0',
                    textRendering: 'geometricPrecision'
                }
            });
            const data = dataUrl.split(',')[1];
            zip.file(`page_${String(i+1).padStart(2,'0')}.png`, data, {base64: true});
        }

        const blob = await zip.generateAsync({type: "blob"});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `card_export_${Date.now()}.zip`;
        link.click();

        currentPage = originalPage;
        applyTransform();
        btn.disabled = false;
        if (statusEl) statusEl.innerText = "å¯¼å‡ºå®Œæˆï¼";
    }

    // åˆå§‹æ¸²æŸ“
    render();
</script>

</body>
</html>